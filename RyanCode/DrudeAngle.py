'''
Calculate the angle distribution of the Drude core - Drude particle pairs with respect to the box vectors.
Also corrects to a probability distribution using a cone correction.

Requires the trajectory files indicated by the list 'Files' to contain only the Drude core and Drude particles.
Can be generated by TRAVIS using the 'proc' function

Built originally for [C4C1im][NTf2], but can be modified by changing the following:
    - Dictionaries
        - ionAtoms is a list of the Drude cores
        - ionDrudes is a list of the Drude particles
        - ionAtomDrude is a dictionary of which Drude core attaches to which Drude particle
        - ionDictionary is a list of indexes for each atom and drude. No order to it, only requires a unique index
    - "if Molecule[:2] == XX" - Change to the first two atoms of the anion and cation. [C4C1im][NTf2] has C8 for the cation and C2 for the anion.
    
The complimentary script "DrudeLength.py" has a built in error check for the Drude core - Drude particle pair and can be used to determine the 
correct assignments for the ionAtomDrude dictionary.
'''

import numpy as np
import matplotlib.pyplot as plt
import sys

# Option to allow printing of whole array, removes the limit on array printing
np.set_printoptions(threshold=np.inf)

# Calculation of the angle between 2 vectors in radians
def angle(a, b):
    magA = np.linalg.norm(a)
    magB = np.linalg.norm(b)
    dotprod = np.dot(a,b)
    cosAng = dotprod/(magA*magB)
    Ang = np.arccos(cosAng)
    return Ang
    
# Create normalisation vector for angle distribution (cone correction)
maxAng=180
normAngleDist = np.zeros(maxAng)
for angles in range(maxAng):
     normAngleDist[angles] = 2*np.pi*(1-np.pi*np.cos((angles+1)*np.pi/180)) - 2*np.pi*(1-np.pi*np.cos((angles)*np.pi/180)) 

noTimeSteps = 20001
noDrudesCat = 10
noDrudesAn = 9
noIons = 256

# Pre-allocate vectors for analysis
drudexAng = np.zeros(noTimeSteps*(noIons*(noDrudesCat+noDrudesAn)) 
drudeyAng = np.zeros(noTimeSteps*(noIons*(noDrudesCat+noDrudesAn))
drudezAng = np.zeros(noTimeSteps*(noIons*(noDrudesCat+noDrudesAn))

anionDrudexAng = np.zeros(noTimeSteps*(noIons*noDrudesAn))
anionDrudeyAng = np.zeros(noTimeSteps*(noIons*noDrudesAn))
anionDrudezAng = np.zeros(noTimeSteps*(noIons*noDrudesAn))

cationDrudexAng = np.zeros(noTimeSteps*(noIons*noDrudesCat))
cationDrudeyAng = np.zeros(noTimeSteps*(noIons*noDrudesCat))
cationDrudezAng = np.zeros(noTimeSteps*(noIons*noDrudesCat))

CationX = np.zeros([noIons,2*noDrudesCat]);CationY = np.zeros([noIons,2*noDrudesCat]);CationZ = np.zeros([noIons,2*noDrudesCat])
AnionX = np.zeros([noIons,2*noDrudesAn]);AnionY = np.zeros([noIons,2*noDrudesAn]);AnionZ = np.zeros([noIons,2*noDrudesAn])

# Dictionaries 
cationAtomDrude = {"C1":"X4","C2":"X3","C3":"X7","C4":"X5","C5":"X6","C6":"X8","C7":"X9","C8":"X10","N1":"X1","N2":"X2"}
cationAtoms = ("C1","C2","C3","C4","C5","C6","C7","C8","N1","N2")
cationDrudes = ("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10")
cationDictionary = {"C1":0,"C2":1,"C3":2,"C4":3,"C5":4,"C6":5,"C7":6,"C8":7,"N1":8,"N2":9,"X1":10,"X2":11,"X3":12,"X4":13,"X5":14,"X6":15,"X7":16,"X8":17,"X9":18,"X10":19}

anionAtomDrude = {"C1":"X3","C2":"X4","S1":"X2","S2":"X1","O1":"X8","O2":"X6","O3":"X7","O4":"X9","N1":"X5"}
anionAtoms = ("C1","C2","S1","S2","O1","O2","O3","O4","N1")
anionDrudes = ("X1","X2","X3","X4","X5","X6","X7","X8","X9")
anionDictionary = {"C1":0,"C2":1,"S1":2,"S2":3,"O1":4,"O2":5,"O3":6,"O4":7,"N1":8,"X1":9,"X2":10,"X3":11,"X4":12,"X5":13,"X6":14,"X7":15,"X8":16,"X9":17}

# File list for analysis
Files = ['../0.000_trajectory_out.xyz','../0.001_trajectory_out.xyz','../0.002_trajectory_out.xyz','../0.005_trajectory_out.xyz',...
    '../0.010_trajectory_out.xyz','../0.020_trajectory_out.xyz','../0.050_trajectory_out.xyz','../0.100_trajectory_out.xyz',...
    '../0.200_trajectory_out.xyz','../0.300_trajectory_out.xyz','../0.400_trajectory_out.xyz','../0.500_trajectory_out.xyz']

for File in Files:

    print File[3:8]
    
    # Reset counters for each file
    xcounter=0
    ycounter=0
    zcounter=0
    tStep=0
    cationxCounter=0
    cationyCounter=0
    cationzCounter=0
    anionxCounter=0
    anionyCounter=0
    anionzCounter=0
    
    # Collect angle data for each file
    for line in open(File):
    
        split = line.split()
        
        if len(split)==7:
            Atom = split[-1]
            Molecule = split[-2]
            
            x = float(split[1])
            y = float(split[2])
            z = float(split[3])
            
            if Molecule[:2] == "C2":
                col = int(anionDictionary[Atom])
                row = int(Molecule[12:-1])-1
                
                AnionX[row,col] = x
                AnionY[row,col] = y
                AnionZ[row,col] = z
                
            if Molecule[:2] == "C8":
                col = int(cationDictionary[Atom])
                row = int(Molecule[11:-1])-1
                
                CationX[row,col] = x
                CationY[row,col] = y
                CationZ[row,col] = z
            
            if Molecule[:2] == "C8" and row == 255 and Atom == "X9":
                
                for atomLabel in cationAtoms:
                    
                    atomLabelNo = cationDictionary[atomLabel]
                    drudeLabel = cationAtomDrude[atomLabel]
                    drudeLabelNo = cationDictionary[drudeLabel]
                    
                    for moleculeNo in range(noIons):
                        
                        xdist = CationX[moleculeNo,atomLabelNo]-CationX[moleculeNo,drudeLabelNo]
                        ydist = CationY[moleculeNo,atomLabelNo]-CationY[moleculeNo,drudeLabelNo]
                        zdist = CationZ[moleculeNo,atomLabelNo]-CationZ[moleculeNo,drudeLabelNo]
                        
                        atomDrudeDist = np.sqrt(xdist**2+ydist**2+zdist**2)
                        
                        if atomDrudeDist>0:
                            atomDrudeVector=np.array([[float(xdist), float(ydist), float(zdist)]])
                            
                            if xdist!=0:
                                drudexAng[xcounter] = angle(atomDrudeVector,np.array([ 1 , 0 , 0 ]))
                                cationDrudexAng[cationxCounter] = drudexAng[xcounter]
                                xcounter+=1
                                cationxCounter+=1
                            else:
                                tmpAng = np.pi/2-((np.random.rand()-0.5)*0.01)
                                drudexAng[xcounter] = tmpAng
                                cationDrudexAng[cationxCounter] = tmpAng
                                xcounter+=1
                                cationxCounter+=1  
                            if ydist!=0:
                                drudeyAng[ycounter] = angle(atomDrudeVector,np.array([ 0 , 1 , 0 ]))
                                cationDrudeyAng[cationyCounter] = drudeyAng[ycounter]
                                ycounter+=1
                                cationyCounter+=1
                            else:
                                tmpAng = np.pi/2-((np.random.rand()-0.5)*0.01)
                                drudeyAng[ycounter] = tmpAng
                                cationDrudeyAng[cationyCounter] = tmpAng
                                ycounter+=1
                                cationyCounter+=1  
                            if zdist!=0:
                                drudezAng[zcounter] = angle(atomDrudeVector,np.array([ 0 , 0 , 1 ]))
                                cationDrudezAng[cationzCounter] = drudezAng[zcounter]
                                zcounter+=1
                                cationzCounter+=1
                            else:
                                tmpAng = np.pi/2-((np.random.rand()-0.5)*0.01)
                                drudezAng[zcounter] = tmpAng
                                cationDrudezAng[cationzCounter] = tmpAng
                                zcounter+=1
                                cationzCounter+=1  
                        else:
                             drudexAng[xcounter] = 0.
                             drudeyAng[ycounter] = 0.
                             drudezAng[zcounter] = 0.
                             cationDrudexAng[cationxCounter] = 0.
                             cationDrudeyAng[cationyCounter] = 0.
                             cationDrudezAng[cationzCounter] = 0.
                             xcounter+=1
                             ycounter+=1
                             zcounter+=1
                             cationxCounter+=1
                             cationyCounter+=1
                             cationzCounter+=1

                for atomLabel in anionAtoms:
                    First=True
                    
                    atomLabelNo = anionDictionary[atomLabel]
                    drudeLabel = anionAtomDrude[atomLabel]
                    drudeLabelNo = anionDictionary[drudeLabel]
                    
                    for moleculeNo in range(noIons):
                        
                        xdist = AnionX[moleculeNo,atomLabelNo]-AnionX[moleculeNo,drudeLabelNo]
                        ydist = AnionY[moleculeNo,atomLabelNo]-AnionY[moleculeNo,drudeLabelNo]
                        zdist = AnionZ[moleculeNo,atomLabelNo]-AnionZ[moleculeNo,drudeLabelNo]
                        
                        atomDrudeDist = np.sqrt(xdist**2+ydist**2+zdist**2)
                        
                        if atomDrudeDist>0:
                            atomDrudeVector=np.array([[float(xdist),float(ydist),float(zdist)]])

                            if xdist!=0:
                                drudexAng[xcounter] = angle(atomDrudeVector,np.array([ 1 , 0 , 0 ]))
                                anionDrudexAng[anionxCounter] = drudexAng[xcounter]
                                xcounter+=1
                                anionxCounter+=1
                            else:
                                tmpAng = np.pi/2-((np.random.rand()-0.5)*0.01)
                                drudexAng[xcounter] = tmpAng
                                anionDrudexAng[anionxCounter] = tmpAng
                                xcounter+=1
                                anionxCounter+=1  
                            if ydist!=0:
                                drudeyAng[ycounter] = angle(atomDrudeVector,np.array([ 0 , 1 , 0 ]))
                                anionDrudeyAng[anionyCounter] = drudeyAng[ycounter]
                                ycounter+=1
                                anionyCounter+=1
                            else:
                                tmpAng = np.pi/2-((np.random.rand()-0.5)*0.01)
                                drudeyAng[zcounter] = tmpAng
                                anionDrudeyAng[anionyCounter] = tmpAng
                                ycounter+=1
                                anionyCounter+=1  
                            if zdist!=0:
                                drudezAng[zcounter] = angle(atomDrudeVector,np.array([ 0 , 0 , 1 ]))
                                anionDrudezAng[anionzCounter] = drudezAng[zcounter]
                                zcounter+=1
                                anionzCounter+=1 
                            else:
                                tmpAng = np.pi/2-((np.random.rand()-0.5)*0.01)
                                drudezAng[zcounter] = tmpAng
                                anionDrudezAng[anionzCounter] = tmpAng
                                zcounter+=1
                                anionzCounter+=1
                
                if tStep == 0:
                    sys.stdout.write("%i of %i" %(tStep+1,noTimeSteps))
                elif tStep == noTimeSteps-1:
                    sys.stdout.flush()
                    sys.stdout.write("\r%i of %i\n" %(tStep+1,noTimeSteps))
                else:
                    sys.stdout.flush()
                    sys.stdout.write("\r%i of %i" %(tStep,noTimeSteps))
                tStep+=1
    
    # Histogram data
    histx = np.histogram(drudexAng[:xcounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    histy = np.histogram(drudeyAng[:ycounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    histz = np.histogram(drudezAng[:zcounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    
    histCatX = np.histogram(cationDrudexAng[:cationxCounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    histCatY = np.histogram(cationDrudeyAng[:cationyCounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    histCatZ = np.histogram(cationDrudezAng[:cationzCounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    
    histAnX = np.histogram(anionDrudexAng[:anionxCounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    histAnY = np.histogram(anionDrudeyAng[:anionyCounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    histAnZ = np.histogram(anionDrudezAng[:anionzCounter], bins=180, range=(0,np.pi), normed=None, weights=None, density=False)
    
    # Turn histograms into data points (rather than ranges)
    rangesX = histx[1]
    xnormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histx[0])
    noPointsX = histx[0]/xnormAngleDist
    rangesY = histy[1]
    ynormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histy[0])
    noPointsY = histy[0]/ynormAngleDist
    rangesZ = histz[1]
    znormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histz[0])
    noPointsZ = histz[0]/znormAngleDist

    rangesCatX = histCatX[1]
    catxnormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histCatX[0])
    noPointsCatX = histCatX[0]/catxnormAngleDist
    rangesCatY = histCatY[1]
    catynormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histCatY[0])
    noPointsCatY = histCatY[0]/catynormAngleDist
    rangesCatZ = histCatZ[1]
    catznormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histCatZ[0])
    noPointsCatZ = histCatZ[0]/catznormAngleDist
        
    rangesAnX = histAnX[1]
    anxnormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histAnX[0])
    noPointsAnX = histAnX[0]/anxnormAngleDist
    rangesAnY = histAnY[1]
    anynormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histAnY[0])
    noPointsAnY = histAnY[0]/anynormAngleDist
    rangesAnZ = histAnZ[1]
    anznormAngleDist=normAngleDist/np.mean(normAngleDist)*np.mean(histAnZ[0])
    noPointsAnZ = histAnZ[0]/anznormAngleDist
    
    # Save outputs to file
    f1 = open(File[3:8] + "_DrudeXAngle.txt","w")
    for k in range(len(noPointsX)):
        f1.write("%f\t%f\n" %(180*np.mean([rangesX[k],rangesX[k+1]])/np.pi,noPointsX[k]))
    f1.close()
    f2 = open(File[3:8] + "_DrudeYAngle.txt","w")
    for k in range(len(noPointsY)):
        f2.write("%f\t%f\n" %(180*np.mean([rangesY[k],rangesY[k+1]])/np.pi,noPointsY[k]))
    f2.close()
    f3 = open(File[3:8] + "_DrudeZAngle.txt","w")
    for k in range(len(noPointsZ)):
        f3.write("%f\t%f\n" %(180*np.mean([rangesZ[k],rangesZ[k+1]])/np.pi,noPointsZ[k]))
    f3.close()
        
    f4 = open(File[3:8] + "_CationDrudeXAngle.txt","w")
    for k in range(len(noPointsCatX)):
        f4.write("%f\t%f\n" %(180*np.mean([rangesCatX[k],rangesCatX[k+1]])/np.pi,noPointsCatX[k]))
    f4.close()
    f5 = open(File[3:8] + "_CationDrudeYAngle.txt","w")
    for k in range(len(noPointsCatY)):
        f5.write("%f\t%f\n" %(180*np.mean([rangesCatY[k],rangesCatY[k+1]])/np.pi,noPointsCatY[k]))
    f5.close()
    f6 = open(File[3:8] + "_CationDrudeZAngle.txt","w")
    for k in range(len(noPointsCatZ)):
        f6.write("%f\t%f\n" %(180*np.mean([rangesCatZ[k],rangesCatZ[k+1]])/np.pi,noPointsCatZ[k]))
    f6.close()

    f7 = open(File[3:8] + "_AnionDrudeXAngle.txt","w")
    for k in range(len(noPointsAnX)):
        f7.write("%f\t%f\n" %(180*np.mean([rangesAnX[k],rangesAnX[k+1]])/np.pi,noPointsAnX[k]))
    f7.close()
    f8 = open(File[3:8] + "_AnionDrudeYAngle.txt","w")
    for k in range(len(noPointsAnY)):
        f8.write("%f\t%f\n" %(180*np.mean([rangesAnY[k],rangesAnY[k+1]])/np.pi,noPointsAnY[k]))
    f8.close()
    f9 = open(File[3:8] + "_AnionDrudeZAngle.txt","w")
    for k in range(len(noPointsAnZ)):
        f9.write("%f\t%f\n" %(180*np.mean([rangesAnZ[k],rangesAnZ[k+1]])/np.pi,noPointsAnZ[k]))
    f9.close()
    
