'''
Takes the anion centre of mass trajectories generated by "SplitIntoComVelFiles.py" and autocorrelates 
along the x, y, and z vectors using the different trajectories.

Complimentary script to "AutocorrelateCationTraj.py"

Also calculates the drift corrected autocorrelation along these vectors.
Each autocorrelation is integrated and saved to a file.

THIS IS A VERY TIME CONSUMING SCRIPT!!!
Often it is better to only autocorrelate one direction at a time, even with multithreading.
To do this, comment out the analysis lines for all vectors except the one desired.
'''

import numpy as np
import multiprocessing

# Autocorrelate vector, normalise and cut to half the length 
# (one side of autocorr is all that's needed for this purpose)
def autocorr(x):
    result = np.correlate(x, x, mode='full')
    resultSize = int(result.size/2)
    result = result[resultSize:]
    normRange = range(len(result),0,-1)
    result = result/normRange
    return result
    
def runAutoCorrX(ionNo):
    print("Autocorrelating anion in X: %i of %i" %(ionNo+1, noIons))
    autoCorrTempX = autocorr(anionXVel[:,ionNo])
    return autoCorrTempX
def runAutoCorrY(ionNo):
    print("Autocorrelating anion in Y: %i of %i" %(ionNo+1, noIons))
    autoCorrTempY = autocorr(anionYVel[:,ionNo])
    return autoCorrTempY
def runAutoCorrZ(ionNo):
    print("Autocorrelating anion in Z: %i of %i" %(ionNo+1, noIons))
    autoCorrTempZ = autocorr(anionZVel[:,ionNo])
    return autoCorrTempZ
    
def runAutoCorrXDrift(ionNo):
    print("Autocorrelating drift corrected anion in X: %i of %i" %(ionNo+1, noIons))
    autoCorrTempX = autocorr(anionXVelDriftCorr[:,ionNo])
    return autoCorrTempX
def runAutoCorrYDrift(ionNo):
    print("Autocorrelating drift corrected anion in Y: %i of %i" %(ionNo+1, noIons))
    autoCorrTempY = autocorr(anionYVelDriftCorr[:,ionNo])
    return autoCorrTempY
def runAutoCorrZDrift(ionNo):
    print("Autocorrelating drift corrected anion in Z: %i of %i" %(ionNo+1, noIons))
    autoCorrTempZ = autocorr(anionZVelDriftCorr[:,ionNo])
    return autoCorrTempZ

timestep = 1.0 #timestep of trajectory in fs, greater than 1 fs not recommended
noIons = 256
tSteps = 1000001

# Import velocities and calculate average velocity along them for drift correction
anionXVel = np.genfromtxt("AnionXTrajectory.txt",delimiter=";"); anionXAvgVel = np.mean(anionXVel)
anionYVel = np.genfromtxt("AnionYTrajectory.txt",delimiter=";"); anionYAvgVel = np.mean(anionYVel)
anionZVel = np.genfromtxt("AnionZTrajectory.txt",delimiter=";"); anionZAvgVel = np.mean(anionZVel)

# Calculate drift corrected velocity arrays
anionXVelDriftCorr = anionXVel - anionXAvgVel
anionYVelDriftCorr = anionYVel - anionYAvgVel
anionZVelDriftCorr = anionZVel - anionZAvgVel

# Pre-allocate autocorrelation vectors
autoCorrAnX = np.zeros([tSteps,noIons])
autoCorrAnY = np.zeros([tSteps,noIons])
autoCorrAnZ = np.zeros([tSteps,noIons])
autoCorrAnXDriftCorr = np.zeros([tSteps,noIons])
autoCorrAnYDriftCorr = np.zeros([tSteps,noIons])
autoCorrAnZDriftCorr = np.zeros([tSteps,noIons])

if __name__ == '__main__': # This if statement is needed for multicore analysis in python, don't ask.....

    diffpool = multiprocessing.Pool(processes=60) # Change processes to the number of cores to run analysis on
    
    autoCorrAnX = diffpool.map(runAutoCorrX, range(noIons))
    autoCorrAnY = diffpool.map(runAutoCorrY, range(noIons))
    autoCorrAnZ = diffpool.map(runAutoCorrZ, range(noIons))
    
    autoCorrAnXDriftCorr = diffpool.map(runAutoCorrXDrift, range(noIons))
    autoCorrAnYDriftCorr = diffpool.map(runAutoCorrYDrift, range(noIons))
    autoCorrAnZDriftCorr = diffpool.map(runAutoCorrZDrift, range(noIons))
    
# Autocorrelation result has one column per ion, this averages the autocorrelation across all ions
autoCorrAnX = np.sum(autoCorrAnX, axis=0);autoCorrAnX = autoCorrAnX/noIons
autoCorrAnY = np.sum(autoCorrAnY, axis=0);autoCorrAnY = autoCorrAnY/noIons
autoCorrAnZ = np.sum(autoCorrAnZ, axis=0);autoCorrAnZ = autoCorrAnZ/noIons

autoCorrAnXDriftCorr = np.sum(autoCorrAnXDriftCorr, axis=0);autoCorrAnXDriftCorr = autoCorrAnXDriftCorr/noIons
autoCorrAnYDriftCorr = np.sum(autoCorrAnYDriftCorr, axis=0);autoCorrAnYDriftCorr = autoCorrAnYDriftCorr/noIons
autoCorrAnZDriftCorr = np.sum(autoCorrAnZDriftCorr, axis=0);autoCorrAnZDriftCorr = autoCorrAnZDriftCorr/noIons

# Calculate integral of autocorrelation
anXInt = np.cumsum(autoCorrAnX*timestep/1000) # Factor of 1000 converts timestep from fs to ps. 
anYInt = np.cumsum(autoCorrAnY*timestep/1000) # SplitIntoComVelFiles.py already converted distance into pm
anZInt = np.cumsum(autoCorrAnZ*timestep/1000)
anXDriftInt = np.cumsum(autoCorrAnXDriftCorr*timestep/1000)
anYDriftInt = np.cumsum(autoCorrAnYDriftCorr*timestep/1000)
anZDriftInt = np.cumsum(autoCorrAnZDriftCorr*timestep/1000)

# Save autocorrelations to file
anXOutFile = "Anion_X.txt"
anxOutWrite = open(anXOutFile,"w")
anxOutWrite.write("#Time [fs]; Velocity Autocorrelation [pm^2/ps^2]; Integral [pm^2/ps]\n") 
for i in range(len(autoCorrAnX)):
    anxOutWrite.write("%f;\t%f;\t%f\n" %(i*timestep,autoCorrAnX[i],anXInt[i]))
anxOutWrite.close()

anYOutFile = "Anion_Y.txt"
anyOutWrite = open(anYOutFile,"w")
anyOutWrite.write("#Time [fs]; Velocity Autocorrelation [pm^2/ps^2]; Integral [pm^2/ps]\n")
for i in range(len(autoCorrAnY)):
    anyOutWrite.write("%f;\t%f;\t%f\n" %(i*timestep,autoCorrAnY[i],anYInt[i]))
anyOutWrite.close()

anZOutFile = "Anion_Z.txt"
anzOutWrite = open(anZOutFile,"w")
anzOutWrite.write("#Time [fs]; Velocity Autocorrelation [pm^2/ps^2]; Integral [pm^2/ps]\n") 
for i in range(len(autoCorrAnZ)):
    anzOutWrite.write("%f;\t%f;\t%f\n" %(i*timestep,autoCorrAnZ[i],anZInt[i]))
anzOutWrite.close()

anXDriftOutFile = "Anion_X_Drift.txt"
anxDriftOutWrite = open(anXDriftOutFile,"w")
anxDriftOutWrite.write("Time [fs]; Velocity Autocorrelation [pm^2/ps^2]; Integral [pm^2/ps]\n")
for i in range(len(autoCorrAnX)):
    anxDriftOutWrite.write("%f;\t%f;\t%f\n" %(i*timestep,autoCorrAnXDriftCorr[i],anXDriftInt[i]))
anxDriftOutWrite.close()

anYDriftOutFile = "Anion_Y_Drift.txt"
anyDriftOutWrite = open(anYDriftOutFile,"w")
anyDriftOutWrite.write("#Time [fs]; Velocity Autocorrelation [pm^2/ps^2]; Integral [pm^2/ps]\n")
for i in range(len(autoCorrAnY)):
    anyDriftOutWrite.write("%f;\t%f;\t%f\n" %(i*timestep,autoCorrAnYDriftCorr[i],anYDriftInt[i]))
anyDriftOutWrite.close()

anZDriftOutFile = "Anion_Z_drift.txt"
anzDriftOutWrite = open(anZDriftOutFile,"w")
anzDriftOutWrite.write("#Time [fs]; Velocity Autocorrelation [pm^2/ps^2]; Integral [pm^2/ps]\n")
for i in range(len(autoCorrAnZ)):
    anzDriftOutWrite.write("%f;\t%f;\t%f\n" %(i*timestep,autoCorrAnZDriftCorr[i],anZDriftInt[i]))
anzDriftOutWrite.close()

