'''
Calculate the length distribution of the Drude core - Drude particle pairs.

Requires the trajectory files indicated by the list 'Files' to contain only the Drude core and Drude particles.
Can be generated by TRAVIS using the 'proc' function

Built originally for [C4C1im][NTf2], but can be modified by changing the following:
    - Dictionaries
        - ionAtoms is a list of the Drude cores
        - ionDrudes is a list of the Drude particles
        - ionAtomDrude is a dictionary of which Drude core attaches to which Drude particle
        - ionDictionary is a list of indexes for each atom and drude. No order to it, only requires a unique index
    - "if Molecule[:2] == XX" - Change to the first two atoms of the anion and cation. [C4C1im][NTf2] has C8 for the 
      cation and C2 for the anion.

The complimentary script "DrudeAngle.py" uses the same dictionary definitions, but doe not have a built in error check for 
the Drude core - Drude particle assignements. This script can be used as a pseudo-debug to get the correct ionAtomDrude 
dictionary definition.
'''

import numpy as np
import matplotlib.pyplot as plt
import sys

noTimeSteps = 20001
noDrudesCat = 10
noDrudesAn = 9
noIons = 256

# Pre-allocate vectors for analysis
DrudeLength = np.zeros(noTimeSteps*(noIons*(noDrudesCat+noDrudesAn))

anionDrudeLength = np.zeros(noTimeSteps*(noIons*noDrudesAn))
cationDrudeLength = np.zeros(noTimeSteps*(noIons*noDrudesCat))

CationX = np.zeros([noIons,2*noDrudesCat]);CationY = np.zeros([noIons,2*noDrudesCat]);CationZ = np.zeros([noIons,2*noDrudesCat])
AnionX = np.zeros([noIons,2*noDrudesAn]);AnionY = np.zeros([noIons,2*noDrudesAn]);AnionZ = np.zeros([noIons,2*noDrudesAn])

# Dictionaries 
cationAtomDrude = {"C1":"X4","C2":"X3","C3":"X7","C4":"X5","C5":"X6","C6":"X8","C7":"X9","C8":"X10","N1":"X1","N2":"X2"}
cationAtoms = ("C1","C2","C3","C4","C5","C6","C7","C8","N1","N2")
cationDrudes = ("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10")
cationDictionary = {"C1":0,"C2":1,"C3":2,"C4":3,"C5":4,"C6":5,"C7":6,"C8":7,"N1":8,"N2":9,"X1":10,"X2":11,"X3":12,"X4":13,"X5":14,"X6":15,"X7":16,"X8":17,"X9":18,"X10":19}

anionAtomDrude = {"C1":"X3","C2":"X4","S1":"X2","S2":"X1","O1":"X8","O2":"X6","O3":"X7","O4":"X9","N1":"X5"}
anionAtoms = ("C1","C2","S1","S2","O1","O2","O3","O4","N1")
anionDrudes = ("X1","X2","X3","X4","X5","X6","X7","X8","X9")
anionDictionary = {"C1":0,"C2":1,"S1":2,"S2":3,"O1":4,"O2":5,"O3":6,"O4":7,"N1":8,"X1":9,"X2":10,"X3":11,"X4":12,"X5":13,"X6":14,"X7":15,"X8":16,"X9":17}

# File list for analysis
Files = ['../0.000_trajectory_out.xyz','../0.001_trajectory_out.xyz','../0.002_trajectory_out.xyz','../0.005_trajectory_out.xyz',...
    '../0.010_trajectory_out.xyz','../0.020_trajectory_out.xyz','../0.050_trajectory_out.xyz','../0.100_trajectory_out.xyz',...
    '../0.200_trajectory_out.xyz','../0.300_trajectory_out.xyz','../0.400_trajectory_out.xyz','../0.500_trajectory_out.xyz']

# Create distance vectors for analysis and print debug info if the drude core-atom distance is too large
for File in Files:
    
    allDrudeCounter=0
    noTsteps=0
    noProblems=0
    cationCounter=0
    anionCounter=0
    
    for line in open(File):
    
        split = line.split()
        
        if len(split)==7:
            Atom = split[-1]
            Molecule = split[-2]
            
            x = float(split[1])
            y = float(split[2])
            z = float(split[3])
            
            if Molecule[:2] == "C2":
                col = int(anionDictionary[Atom])
                row = int(Molecule[12:-1])-1
                
                AnionX[row,col] = x
                AnionY[row,col] = y
                AnionZ[row,col] = z
                
            if Molecule[:2] == "C8":
                col = int(cationDictionary[Atom])
                row = int(Molecule[11:-1])-1
                
                CationX[row,col] = x
                CationY[row,col] = y
                CationZ[row,col] = z
            
            if Molecule[:2] == "C8" and row == 255 and Atom == "X9":
                
                for atomLabel in cationAtoms:
                    
                    atomLabelNo = cationDictionary[atomLabel]
                    
                    for moleculeNo in range(256):
                        
                        atomDrudeDist = np.zeros(10)
                        k=0
                        
                        for drudeLabel in cationDrudes:
                            
                            drudeLabelNo = cationDictionary[drudeLabel]
                                                
                            xdist = CationX[moleculeNo,atomLabelNo]-CationX[moleculeNo,drudeLabelNo]
                            ydist = CationY[moleculeNo,atomLabelNo]-CationY[moleculeNo,drudeLabelNo]
                            zdist = CationZ[moleculeNo,atomLabelNo]-CationZ[moleculeNo,drudeLabelNo]
                        
                            atomDrudeDist[k] = np.sqrt(xdist**2+ydist**2+zdist**2)
                            k+=1 
                        
                        DrudeLength[i] = min(atomDrudeDist)
                        cationDrudeLength[cationCounter] = min(atomDrudeDist)
                        
                        allDrudeCounter+=1
                        cationCounter+=1
                        
                        if  min(atomDrudeDist)>1 and moleculeNo != 255:
                             noProblems+=1
                        if noProblems!=0 and moleculeNo == 255:
                            if  min(atomDrudeDist)>1:
                                noProblems+=1
                            print "Problem combo is in anion at %s and %s with %i errors" %(atomLabel, drudeLabel, noProblems)
                            noProblems=0
                        
                for atomLabel in anionAtoms:
                    
                    atomLabelNo = anionDictionary[atomLabel]
                    
                    for moleculeNo in range(256):
                        
                        atomDrudeDist = np.zeros(9)
                        k=0
                        
                        for drudeLabel in anionDrudes:
                            
                            drudeLabelNo = anionDictionary[drudeLabel]
                                                
                            xdist = AnionX[moleculeNo,atomLabelNo]-AnionX[moleculeNo,drudeLabelNo]
                            ydist = AnionY[moleculeNo,atomLabelNo]-AnionY[moleculeNo,drudeLabelNo]
                            zdist = AnionZ[moleculeNo,atomLabelNo]-AnionZ[moleculeNo,drudeLabelNo]
                        
                            atomDrudeDist[k] = np.sqrt(xdist**2+ydist**2+zdist**2)
                            k+=1 
                        
                        DrudeLength[i] = min(atomDrudeDist)
                        anionDrudeLength[anionCounter] = min(atomDrudeDist)
                        
                        allDrudeCounter+=1
                        anionCounter+=1
                        
                        if min(atomDrudeDist)>1 and moleculeNo != 255:
                            noProblems+=1
                        if noProblems!=0 and moleculeNo == 255:
                            if  min(atomDrudeDist)>1:
                                noProblems+=1
                            print "Problem combo is in anion at %s and %s with %i errors" %(atomLabel, drudeLabel, noProblems)
                            noProblems=0
                
                if tStep == 0:
                    sys.stdout.write("%i of %i" %(tStep+1,noTimeSteps))
                elif tStep == noTimeSteps-1:
                    sys.stdout.flush()
                    sys.stdout.write("\r%i of %i\n" %(tStep+1,noTimeSteps))
                else:
                    sys.stdout.flush()
                    sys.stdout.write("\r%i of %i" %(tStep,noTimeSteps))
                tStep+=1
    
    # Histogram data
    hist = np.histogram(DrudeLength[:i], bins=500, range=(0,0.25), normed=None, weights=None, density=False)
    histCat = np.histogram(cationDrudeLength[:i], bins=500, range=(0,0.25), normed=None, weights=None, density=False)
    histAn = np.histogram(anionDrudeLength[:i], bins=500, range=(0,0.25), normed=None, weights=None, density=False)
    
    # Turn histograms into data points from ranges and save output to file
    ranges = hist[1]
    noPoints = hist[0]
    rangesCat = histCat[1]
    noPointsCat = histCat[0]
    rangesAn = histAn[1]
    noPointsAn = histAn[0]
    
    f1 = open(File[3:8] + "_DrudeLength.txt","w")
    for i in range(len(noPoints)):
        f1.write("%f\t%f\n" %(np.mean([ranges[i],ranges[i+1]]),noPoints[i]))
    f1.close()
    
    f2 = open(File[3:8] + "_CationDrudeLength.txt","w")
    for i in range(len(noPointsCat)):
        f2.write("%f\t%f\n" %(np.mean([rangesCat[i],rangesCat[i+1]]),noPointsCat[i]))
    f2.close()
    f3 = open(File[3:8] + "_AnionDrudeLength.txt","w")
    for i in range(len(noPointsAn)):
        f3.write("%f\t%f\n" %(np.mean([rangesAn[i],rangesAn[i+1]]),noPointsAn[i]))
    f3.close()
    
